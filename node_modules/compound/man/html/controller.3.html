<!DOCTYPE html>
<html>
<head>
  <meta http-equiv='content-type' value='text/html;charset=utf8'>
  <meta name='generator' value='Ronn/v0.7.3 (http://github.com/rtomayko/ronn/tree/0.7.3)'>
  <title>compound-controller(3) - controllers API</title>
  <style type='text/css' media='all'>
  /* style: man */
  body#manpage {margin:0}
  .mp {max-width:100ex;padding:0 9ex 1ex 4ex}
  .mp p,.mp pre,.mp ul,.mp ol,.mp dl {margin:0 0 20px 0}
  .mp h2 {margin:10px 0 0 0}
  .mp > p,.mp > pre,.mp > ul,.mp > ol,.mp > dl {margin-left:8ex}
  .mp h3 {margin:0 0 0 4ex}
  .mp dt {margin:0;clear:left}
  .mp dt.flush {float:left;width:8ex}
  .mp dd {margin:0 0 0 9ex}
  .mp h1,.mp h2,.mp h3,.mp h4 {clear:left}
  .mp pre {margin-bottom:20px}
  .mp pre+h2,.mp pre+h3 {margin-top:22px}
  .mp h2+pre,.mp h3+pre {margin-top:5px}
  .mp img {display:block;margin:auto}
  .mp h1.man-title {display:none}
  .mp,.mp code,.mp pre,.mp tt,.mp kbd,.mp samp,.mp h3,.mp h4 {font-family:monospace;font-size:14px;line-height:1.42857142857143}
  .mp h2 {font-size:16px;line-height:1.25}
  .mp h1 {font-size:20px;line-height:2}
  .mp {text-align:justify;background:#fff}
  .mp,.mp code,.mp pre,.mp pre code,.mp tt,.mp kbd,.mp samp {color:#131211}
  .mp h1,.mp h2,.mp h3,.mp h4 {color:#030201}
  .mp u {text-decoration:underline}
  .mp code,.mp strong,.mp b {font-weight:bold;color:#131211}
  .mp em,.mp var {font-style:italic;color:#232221;text-decoration:none}
  .mp a,.mp a:link,.mp a:hover,.mp a code,.mp a pre,.mp a tt,.mp a kbd,.mp a samp {color:#0000ff}
  .mp b.man-ref {font-weight:normal;color:#434241}
  .mp pre {padding:0 4ex}
  .mp pre code {font-weight:normal;color:#434241}
  .mp h2+pre,h3+pre {padding-left:0}
  ol.man-decor,ol.man-decor li {margin:3px 0 10px 0;padding:0;float:left;width:33%;list-style-type:none;text-transform:uppercase;color:#999;letter-spacing:1px}
  ol.man-decor {width:100%}
  ol.man-decor li.tl {text-align:left}
  ol.man-decor li.tc {text-align:center;letter-spacing:4px}
  ol.man-decor li.tr {text-align:right;float:right}
  </style>
  <style type='text/css' media='all'>
  /* style: toc */
  .man-navigation {display:block !important;position:fixed;top:0;left:113ex;height:100%;width:100%;padding:48px 0 0 0;border-left:1px solid #dbdbdb;background:#eee}
  .man-navigation a,.man-navigation a:hover,.man-navigation a:link,.man-navigation a:visited {display:block;margin:0;padding:5px 2px 5px 30px;color:#999;text-decoration:none}
  .man-navigation a:hover {color:#111;text-decoration:underline}
  </style>
</head>
<!--
  The following styles are deprecated and will be removed at some point:
  div#man, div#man ol.man, div#man ol.head, div#man ol.man.

  The .man-page, .man-decor, .man-head, .man-foot, .man-title, and
  .man-navigation should be used instead.
-->
<body id='manpage'>
  <div class='mp' id='man'>

  <div class='man-navigation' style='display:none'>
    <a href="#NAME">NAME</a>
    <a href="#DESCRIPTION">DESCRIPTION</a>
    <a href="#SYNOPSIS">SYNOPSIS</a>
    <a href="#FILES">FILES</a>
    <a href="#FEATURES">FEATURES</a>
    <a href="#EXTENDING">EXTENDING</a>
    <a href="#CONTRIBUTION">CONTRIBUTION</a>
    <a href="#SEE-ALSO">SEE ALSO</a>
  </div>

  <ol class='man-decor man-head man head'>
    <li class='tl'>compound-controller(3)</li>
    <li class='tc'>CompoundJS</li>
    <li class='tr'>compound-controller(3)</li>
  </ol>

  <h2 id="NAME">NAME</h2>
<p class="man-name">
  <code>compound-controller</code> - <span class="man-whatis">controllers API</span>
</p>

<h2 id="DESCRIPTION">DESCRIPTION</h2>

<p>Controller is a module that receives http request and handles response.
Controller consists of a set of actions. Each action is called by the
request of a particular route.</p>

<h2 id="SYNOPSIS">SYNOPSIS</h2>

<p>Controller receives control from router, if more then one routes matched by
request - first route will be served, then second, third, etc..</p>

<p>It means that one request could be handled by one or more controllers matched by
router sequentially until one of controllers will produce output.</p>

<p>When no controllers produces output, then control returned to next middleware
after express.router.</p>

<h2 id="FILES">FILES</h2>

<p>Controllers automatically loaded from <code>./app/controllers</code> directory.</p>

<p>Compound have two kind of controllers: when file name ended with <code>_controller</code>
this is <strong>eval</strong> controller, otherwise controller is <strong>noeval</strong>.</p>

<h3 id="EVAL-CONTROLLERS">EVAL CONTROLLERS</h3>

<p>The purpose of eval controller - provide convenient interface with less code
and more expression. But it have price: harder debugging and lack of usual
features such as inheritance, meta-programming and using relative <code>require</code>.</p>

<p>By default compound generators create eval controllers, but this behavior will
be changed in future because eval is evil. See <a href="#USING-EVAL-CONTROLLERS" title="USING EVAL CONTROLLERS" data-bare-link="true">USING EVAL CONTROLLERS</a>
section for specific usage details.</p>

<p>Example of eval controller: <code>app/controllers/car_controller.js</code>:</p>

<pre><code>load('essentials'); // load parent controller

before(function think() {
    // think for 1 second before acceperate
    setTimeout(function() {
        next();
    });
}, {only: 'accelerate'});

action('accelerate', function() {
    send(++this.speed);
});

action('brake', function() {
    send(--this.speed);
});
</code></pre>

<h3 id="NOEVAL-CONTROLLERS">NOEVAL CONTROLLERS</h3>

<p>The opposite way to do the same things as in eval controller: more verbose, a
little bit harder to read, but easier in debug. Works as usual class: allows
inheritance, meta-programming, using require and all regular features.</p>

<p>Example of noeval controller: <code>app/controllers/car.js</code>:</p>

<pre><code>module.exports = CarController;

// load parent controller
var Essentials = require('./essentials');

function CarController(init) {
    // call parent constructor
    Essentials.call(this, init);

    init.before(function think(c) {
        // think for 1 second before accelerate
        setTimeout(function() {
            c.next();
        });
    }, {only: 'accelerate'});
}

// setup inheritance
require('util').inherits(CarController, Essentials);

CarController.prototype.accelerate = function(c) {
    c.send(++this.speed);
};

CarController.prototype.brake = function(c) {
    c.send(++this.speed);
};
</code></pre>

<p>See <a href="#USING-NOEVAL-CONTROLLERS" title="USING NOEVAL CONTROLLERS" data-bare-link="true">USING NOEVAL CONTROLLERS</a> section for specific usage details.</p>

<h3 id="COMMON-PARTS-AND-THE-DIFFERENCE">COMMON PARTS AND THE DIFFERENCE</h3>

<p>Main difference between eval and noeval controllers: using controller context.
In case of eval it is possible just call controller context members as global
variables: next, req, res, send, render and other features. In noeval controller
each action and hook accepts context object as first argument, all context
features available on this object.</p>

<h3 id="USING-EVAL-CONTROLLERS">USING EVAL CONTROLLERS</h3>

<p>To define action call `action(name, fn) method. This method accepts 1 or 2
arguments. First argument (String name) is optional when named fn passed as
action handler.</p>

<p>To define hook just call <code>before</code> or <code>after</code> methods.</p>

<h3 id="USING-NOEVAL-CONTROLLERS">USING NOEVAL CONTROLLERS</h3>

<p>Noeval controller file should export constructor, actions are prototype methods
of that constructor. Controller constructor accepts <code>init</code> object which allows
to configure controller on creation.</p>

<p>To define hook call <code>before</code> or <code>after</code> on <code>init</code> object passed to constructor.</p>

<h2 id="FEATURES">FEATURES</h2>

<p>Controller context has the following set of methods and members:</p>

<h3 id="COMMON-MEMBERS">COMMON MEMBERS</h3>

<dl>
<dt class="flush"><code>req</code></dt><dd><p>Request object (instance of http.IncomingMessage)</p></dd>
<dt class="flush"><code>res</code></dt><dd><p>Response object (instance of http.ServerResponse)</p></dd>
<dt class="flush"><code>body</code></dt><dd><p>Request body (null in case of GET)</p></dd>
</dl>


<h3 id="COMMON-METHODS">COMMON METHODS</h3>

<p><strong>NOTE:</strong> Each action should invoke exactly one output method (render, send).
This is the only requirement imposed by the asynchronous nature of Node.js. If
you don't call an output method, the client will infinitely wait for a server
response.</p>

<dl>
<dt><code>render([view[, params]])</code>:</dt><dd><p></p>

<p>Render view and send result to client.</p>

<p>The <code>render</code> method accepts 0, 1 or 2 arguments. When called without any
arguments, it just renders the view associated with current action. For
example, this will render <code>app/views/posts/index.ejs</code>.</p>

<p>Fragment of <code>app/controllers/posts.js</code>:</p>

<pre><code>PostsController.prototype.index = function index(c) {
    c.render();
});
</code></pre>

<p>To pass some data to the view, there are two ways to do it. The first is to
simply pass a hash containing the data:</p>

<p>Fragment of <code>app/controllers/posts.js</code>:</p>

<pre><code>PostsController.prototype.index = function index(c) {
    this.data = [];
    c.render({title: 'Posts index'});
});
</code></pre>

<p>Example above will render 'posts/index' view passing <code>title</code> and <code>data</code> to it.</p>

<p>To render another view, just put its name as the first argument:</p>

<p>Fragment of <code>app/controllers/posts.js</code>:</p>

<pre><code>PostsController.prototype.update = function update(c) {
    this.title = 'Edit post';
    c.render('edit');
};
</code></pre></dd>
<dt><code>send(smth)</code></dt><dd><p>Send text, status code or json object to client</p>

<p>The <code>send</code> function is useful for debugging and one-page apps where you don't
want to render a heavy template and just want to send text or JSON data.</p>

<p>This function can be called with a status code number:</p>

<pre><code>Controller.prototype.destroy = function destroy(c) {
    // client will receive statusCode = 403 Forbidden
    c.send(403);
});
</code></pre>

<p>or with a string:</p>

<pre><code>Controller.prototype.sayHello = function sayHello(c) {
    // client will receive 'Hello!'
    c.send('Hello!');
});
</code></pre>

<p>or with an object:</p>

<pre><code>Controller.prototype.action = function action(c) {
    // client will receive '{"hello":"world"}'
    c.send({ hello: 'world' });
});
</code></pre></dd>
<dt><code>redirect(location)</code></dt><dd><p>Redirect client to specific location</p>

<p>This function just sets the status code and <code>Location</code> header, so the client
will be redirected to another location.</p>

<pre><code>redirect('/'); // root redirection
redirect('http://example.com'); // redirect to another host
</code></pre></dd>
<dt class="flush"><code>header</code></dt><dd><p>Send header to client</p></dd>
<dt><code>flash(type, message)</code></dt><dd><p>Display flash message</p>

<p>The <code>flash</code> function stores a message in the session to be displayed later.
Here are a few examples:</p>

<p>Fragment of <code>app/controllers/posts.js</code>:</p>

<pre><code>PostsController.prototype.create = function create(c) {
    c.Post.create(req.body, function (err) {
        if (err) {
            c.flash('error', 'Error while post creation');
            c.render('new', {post: req.body});
        } else {
            c.flash('info', 'Post has been successfully created');
            c.redirect(c.pathTo.posts);
        }
    });
});
</code></pre>

<p>This <code>create</code> action sends a flash info on success and a flash error on fail.</p></dd>
<dt><code>before([name, ]hook[, params])</code></dt><dd><p>Invoke <code>hook</code> before any action. Name param is optional when hook is named
function. Examples of params object:</p>

<pre><code>{ only: ['actionName', 'actionName2'] }
{ except: 'anotherActionName' }
</code></pre>

<p>First configuration will run hook only for <code>actionName</code> and <code>actionName2</code>
actions.  Second configuration will run hook before each action except
<code>anotherActionName</code>.</p>

<p>To provide the ability of DRY-ing controller code and reusing common code
parts, CompoundJS provides a few additional tools: method chaining and
external controllers loading.</p>

<p>To chain methods, you can use the <code>before</code> and <code>after</code> methods.</p>

<p>Fragment of <code>app/controllers/checkout.js</code></p>

<pre><code>function CheckoutController(init) {
    init.before(userRequired, { only: 'order' });
    init.before(prepareBasket, { except: 'order' });
    init.before(loadProducts, { only: ['products', 'featuredProducts'] });
}

CheckoutController.prototype.products = function(c) { ... };
CheckoutController.prototype.featuredProducts = function(c) { ... };
CheckoutController.prototype.order = function(c) { ... };
CheckoutController.prototype.basket = function(c) { ... };

function userRequired(c) { c.next() }
function prepareBasket(c) { c.next() }
function loadProducts(c) { c.next() }
</code></pre>

<p>In this example, <code>userRequired</code> will be called only for the <code>order</code> action,
<code>prepareBasket</code> will be called for all actions except <code>order</code>, and
<code>loadProducts</code> will be called only for the <code>products</code> and
<code>featuredProducts</code>methods.</p>

<p>Note, that the before-functions should call the global <code>next</code> method that will
pass control to the next function in the chain.</p></dd>
<dt><code>after([name, ]hook[, params])</code></dt><dd><p>Invoke <code>hook</code> after any action. Name param is optional when hook is named
function. Params object is the same as for before hook.</p></dd>
<dt><code>skipBefore(name, params)</code></dt><dd><p>Skip before hook by it's name. Params object allows to specify skip/only
actions.</p></dd>
<dt><code>skipBefore(name, params)</code></dt><dd><p>Skip before hook by it's name. Params object allows to specify skip/only
actions.</p></dd>
<dt><code>next(err)</code></dt><dd><p>Go to next hook/action in chain. When error param passed to next rest of chain
skipped and error passed to error handling middleware.</p></dd>
</dl>


<h3 id="EVAL-ONLY-METHODS">EVAL-ONLY METHODS</h3>

<p>Eval have a bunch of shims to allow code sharing between controllers (noeval
doesn't need it, because it could use require and inheritance).</p>

<dl>
<dt class="flush"><code>load</code></dt><dd><p>Load another controller to use its methods.</p></dd>
<dt class="flush"><code>use</code></dt><dd><p>Get method defined in another controller, loaded using <code>load</code>.</p></dd>
<dt class="flush"><code>publish</code></dt><dd><p>Allow method to be used in other controller.</p>

<p>Some methods, like <code>userRequired</code> for example, can be used in different
controllers. To allow cross-controller code sharing, CompoundJS provides a few
methods: <code>load</code>, <code>use</code> and <code>publish</code>.</p>

<p>You can define <code>requireUser</code> in <code>application_controller.js</code> and call <code>publish</code>
to make it accessible to all other controllers that inherit from this
controller:</p>

<p>Fragment of <code>app/controllers/application_controller.js</code>:</p>

<pre><code>publish('requireUser', requireUser);

function requireUser () {
    // ...
}
</code></pre>

<p>Fragment of <code>app/controllers/products_controller.js</code>:</p>

<pre><code>load('application'); // note that _controller siffix omitted
before(use('userRequired'), { only: 'products' });
</code></pre></dd>
</dl>


<h3 id="COMMON-EXECUTION-CONTEXT">COMMON EXECUTION CONTEXT</h3>

<p>There is one extra feature in flow control: All functions are invoked in the same context, so you can pass data between the functions using the <code>this</code> object:</p>

<pre><code>function loadProducts () {
    Product.find(function (err, prds) {
        this.products = prds;
        next();
    }.bind(this));
}

action('products', function () {
    assert.ok(this.products, 'Products available here');
    render(); // also products will available in view
});
</code></pre>

<h2 id="EXTENDING">EXTENDING</h2>

<p>To extend controller context use <code>compound.controllerExtensions</code> object. Methods
of that object will be mixed to each controller context.</p>

<p>For example, add method on initialization:</p>

<pre><code>compound.controllerExtensions.socketSend = function(arg) {
    socketIO.send(arg);
};
</code></pre>

<p>Then it will be possible to call <code>socket('hello')</code> in eval controller, and
<code>c.socket('hello')</code> in noeval controller.</p>

<h2 id="CONTRIBUTION">CONTRIBUTION</h2>

<p>Compound uses npm package <a href="http://npmjs.org/package/kontroller">kontroller</a> to
handle controllers. Any patches, feature requests or bug reports are welcome to
its <a href="https://github.com/1602/kontroller">github repository: 1602/kontroller</a>.</p>

<h2 id="SEE-ALSO">SEE ALSO</h2>

<p><a class="man-ref" href="views.3.html">compound-views<span class="s">(3)</span></a> <a class="man-ref" href="helpers.3.html">compound-helpers<span class="s">(3)</span></a></p>


  <ol class='man-decor man-foot man foot'>
    <li class='tl'>1602 Software</li>
    <li class='tc'>March 2013</li>
    <li class='tr'>compound-controller(3)</li>
  </ol>

  </div>
</body>
</html>
